---
import type { SanityDocument } from "@sanity/client";
import usaStates from "@severo_bo/us-atlas-2023/states-albers-10m.json";
import type { Feature } from "geojson";
import { feature } from "topojson-client";
import type { GeometryCollection, Topology } from "topojson-specification";
import { formatStateList } from "~/helpers/helpers";
import { loadQuery } from "~/sanity/lib/loadQuery";

interface StateData extends SanityDocument {
  name: string;
  slug: string;
  namesakeSupport: "full" | "prioritized" | "none";
}

interface StateFeature extends Feature {
  properties: {
    name: string;
    supportLevel: "full" | "prioritized" | "none";
    [key: string]: unknown;
  };
}

const { data: states } = await loadQuery<StateData[]>({
  query: `*[_type == "state"]{
    name,
    "slug": slug.current,
    namesakeSupport
  }`,
});

function processStateFeatures(states: StateData[]): StateFeature[] {
  const stateSupport = states.reduce(
    (acc, state) => {
      acc[state.name] = state.namesakeSupport || "none";
      return acc;
    },
    {} as Record<string, string>,
  );

  const topology = usaStates as unknown as Topology;
  const featureCollection = feature(
    topology,
    topology.objects.states as GeometryCollection,
  );

  return featureCollection.features.map(
    (geoFeature: Feature): StateFeature => ({
      ...geoFeature,
      properties: {
        ...geoFeature.properties,
        name: geoFeature.properties?.name || "",
        supportLevel: (stateSupport[geoFeature.properties?.name] || "none") as
          | "full"
          | "prioritized"
          | "none",
      },
    }),
  );
}

const stateFeatures = processStateFeatures(states);
const fullSupportStates = states
  .filter((state) => state.namesakeSupport === "full")
  .map((state) => state.name);
const prioritizedStates = states
  .filter((state) => state.namesakeSupport === "prioritized")
  .map((state) => state.name);

const supportMessage = `We fully support ${formatStateList(fullSupportStates)}, and we are prioritizing support for ${formatStateList(prioritizedStates)} next.`;
---

<section class="support">
  <header>
    <h2>States we support</h2>
    <p set:html={supportMessage} />
  </header>
  <div id="support-map" data-states={JSON.stringify(stateFeatures)}></div>
</section>

<script>
  import * as d3 from "d3";

  const MAP_CONFIG = {
    width: 975,
    height: 610,
    legendPosition: { x: 0.8, y: 40 },
    patterns: {
      hatch: { width: 5, height: 5, strokeWidth: 1.4 },
      dots: { width: 4, height: 4, radius: 0.6 },
    },
  };

  const container = document.querySelector("#support-map") as HTMLElement;
  const stateFeatures = JSON.parse(container?.dataset.states || "[]");

  const path = d3.geoPath();
  const svg = d3
    .create("svg")
    .attr("viewBox", `0 0 ${MAP_CONFIG.width} ${MAP_CONFIG.height}`)
    .attr("style", "max-width: 100%; height: auto;");

  const defs = svg.append("defs");

  const hatchPattern = defs
    .append("pattern")
    .attr("id", "hatchmarks")
    .attr("patternUnits", "userSpaceOnUse")
    .attr("width", MAP_CONFIG.patterns.hatch.width)
    .attr("height", MAP_CONFIG.patterns.hatch.height);

  ["M-1,6 L6,-1", "M-1,1 L1,-1", "M4,6 L6,4"].forEach((pathData) => {
    hatchPattern
      .append("path")
      .attr("d", pathData)
      .attr("stroke", "var(--text)")
      .attr("stroke-linecap", "square")
      .attr("stroke-width", MAP_CONFIG.patterns.hatch.strokeWidth);
  });

  const dotPattern = defs
    .append("pattern")
    .attr("id", "dots")
    .attr("patternUnits", "userSpaceOnUse")
    .attr("width", MAP_CONFIG.patterns.dots.width)
    .attr("height", MAP_CONFIG.patterns.dots.height);

  [
    { cx: 1, cy: 1 },
    { cx: 3, cy: 3 },
  ].forEach((pos) => {
    dotPattern
      .append("circle")
      .attr("cx", pos.cx)
      .attr("cy", pos.cy)
      .attr("r", MAP_CONFIG.patterns.dots.radius)
      .attr("fill", "var(--text)");
  });

  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "state-tooltip")
    .style("position", "absolute")
    .style("visibility", "hidden")
    .style("background", "var(--text)")
    .style("color", "var(--bg)")
    .style("padding", "8px 12px")
    .style("border-radius", "4px")
    .style("font-size", "14px")
    .style("pointer-events", "none")
    .style("z-index", "1000");

  const paths = svg
    .selectAll("path.state")
    .data(stateFeatures)
    .enter()
    .append("path")
    .attr("d", (d: any) => path(d))
    .attr("class", "state")
    .attr("stroke", "var(--bg)")
    .attr("stroke-linecap", "round")
    .attr("stroke-linejoin", "round")
    .attr("stroke-width", 1.5);

  paths.each(function (d: any) {
    const element = d3.select(this);
    const supportLevel = d.properties.supportLevel;
    const fillMap = {
      full: "var(--text)",
      prioritized: "url(#hatchmarks)",
      none: "url(#dots)",
    };

    element
      .attr(
        "fill",
        fillMap[supportLevel as keyof typeof fillMap] || "url(#dots)",
      )
      .attr("data-support", supportLevel)
      .attr("data-name", d.properties.name);
  });

  paths
    .on("mouseover", function (_event, d: any) {
      const supportLevel = d.properties.supportLevel;
      const textMap = {
        full: "Full Support",
        prioritized: "Support Coming Soon",
        none: "No Support Yet",
      };
      const supportText =
        textMap[supportLevel as keyof typeof textMap] || "No Support Yet";

      const hoveredState = d3.select(this);
      hoveredState.attr("stroke", "var(--text)").attr("stroke-width", 2.5);

      const node = hoveredState.node();
      if (node && node.parentNode) node.parentNode.appendChild(node);

      tooltip
        .style("visibility", "visible")
        .html(`<strong>${d.properties.name}</strong><br/>${supportText}`);
    })
    .on("mousemove", function (event: any) {
      tooltip
        .style("top", event.pageY + 16 + "px")
        .style("left", event.pageX + 16 + "px");
    })
    .on("mouseout", function () {
      paths.attr("stroke", "var(--bg)").attr("stroke-width", 2);
      tooltip.style("visibility", "hidden");
    });

  const supportCounts = stateFeatures.reduce(
    (counts: Record<string, number>, feature: any) => {
      const level = feature.properties.supportLevel;
      counts[level] = (counts[level] || 0) + 1;
      return counts;
    },
    {},
  );

  const legendData = [
    {
      type: "full",
      label: "Full Support",
      fill: "var(--text)",
      count: supportCounts.full || 0,
    },
    {
      type: "prioritized",
      label: "Next Up",
      fill: "url(#hatchmarks)",
      count: supportCounts.prioritized || 0,
    },
    {
      type: "none",
      label: "No Support Yet",
      fill: "url(#dots)",
      count: supportCounts.none || 0,
    },
  ];

  const legendGroup = svg
    .append("g")
    .attr("class", "legend")
    .attr(
      "transform",
      `translate(${MAP_CONFIG.width * MAP_CONFIG.legendPosition.x}, ${MAP_CONFIG.legendPosition.y})`,
    );

  const legendItems = legendGroup
    .selectAll(".legend-item")
    .data(legendData)
    .enter()
    .append("g")
    .attr("class", "legend-item")
    .attr("transform", (_d: any, i: number) => `translate(0, ${i * 24})`);

  legendItems
    .append("rect")
    .attr("x", -85)
    .attr("y", -12)
    .attr("width", 160)
    .attr("height", 24)
    .attr("fill", "transparent")
    .style("cursor", "pointer");

  legendItems
    .append("text")
    .attr("x", -88)
    .attr("y", 5)
    .attr("font-size", "16px")
    .attr("fill", "var(--text)")
    .attr("text-anchor", "end")
    .text((d: any) => d.count);

  legendItems
    .append("rect")
    .attr("x", -80)
    .attr("y", -8)
    .attr("width", 16)
    .attr("height", 16)
    .attr("fill", (d: any) => d.fill)
    .attr("stroke", "var(--text)")
    .attr("stroke-width", 1.5)
    .attr("rx", 2);

  legendItems
    .append("text")
    .attr("x", -56)
    .attr("y", 5)
    .attr("font-size", "16px")
    .attr("fill", "var(--text)")
    .attr("text-anchor", "start")
    .text((d: any) => d.label);

  legendItems
    .style("cursor", "pointer")
    .on("mouseover", function (_event: any, d: any) {
      const hoveredType = d.type;

      paths.style("opacity", 0.1);

      paths
        .filter(
          (stateData: any) => stateData.properties.supportLevel === hoveredType,
        )
        .attr("stroke", "var(--text)")
        .attr("stroke-width", 2.5)
        .style("opacity", 1);

      d3.select(this).style("opacity", 1);

      legendItems
        .filter((legendData: any) => legendData.type !== hoveredType)
        .style("opacity", 0.6);
    })
    .on("mouseout", function () {
      paths
        .style("opacity", 1)
        .attr("stroke", "var(--bg)")
        .attr("stroke-width", 2);

      legendItems.style("opacity", 1);
    });

  const svgNode = svg.node();
  if (container && svgNode) {
    container.append(svgNode);
  }
</script>

<style>
  .support {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-2xl);
    padding-block: var(--space-3xl);
  }

  header {
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-m);
    text-wrap: balance;
  }

  #support-map {
    width: 100%;
    max-width: 975px;
    margin: 0 auto;
  }
</style>
