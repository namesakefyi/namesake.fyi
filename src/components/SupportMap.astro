---
import type { SanityDocument } from "@sanity/client";
import { feature } from "topojson-client";
import { loadQuery } from "~/sanity/lib/loadQuery";
import usaStates from "@severo_bo/us-atlas-2023/states-albers-10m.json";
import { formatStateList } from "~/helpers/helpers";

const { data: states } = await loadQuery<SanityDocument[]>({
  query: `*[_type == "state"]{
    name,
    "slug": slug.current,
    namesakeSupport
  }`,
});

// Create a lookup map for state support status by state name
const stateSupport = states.reduce(
  (acc, state) => {
    acc[state.name] = state.namesakeSupport || "none";
    return acc;
  },
  {} as Record<string, string>,
);

// Convert TopoJSON to GeoJSON features and add support data on the server
const stateFeatures = feature(usaStates, usaStates.objects.states).features.map(
  (geoFeature: any) => ({
    ...geoFeature,
    properties: {
      ...geoFeature.properties,
      supportLevel: stateSupport[geoFeature.properties.name] || "none",
    },
  }),
);

// Get state lists
const fullSupportStates = states
  .filter((state) => state.namesakeSupport === "full")
  .map((state) => state.name);

const prioritizedStates = states
  .filter((state) => state.namesakeSupport === "prioritized")
  .map((state) => state.name);

// Compose the complete support message
const supportMessage = `We fully support ${formatStateList(fullSupportStates)}. We are prioritizing support for ${formatStateList(prioritizedStates)} next.`;
---

<section class="support">
  <header>
    <h2>Where we support</h2>
    <p set:html={supportMessage} />
  </header>
  <div id="support-map" data-states={JSON.stringify(stateFeatures)}></div>
</section>

<script>
  // @ts-ignore - D3 types may not be properly configured
  import * as d3 from "d3";

  const width = 975;
  const height = 610;

  const path = d3.geoPath();

  const container = document.querySelector("#support-map") as HTMLElement;

  const stateFeatures = JSON.parse(container?.dataset.states || "[]");

  const svg = d3
    .create("svg")
    .attr("viewBox", `0 0 ${width} ${height}`)
    .attr("style", "max-width: 100%; height: auto;");

  const defs = svg.append("defs");

  // Hatchmark pattern for prioritized states
  const hatchPattern = defs
    .append("pattern")
    .attr("id", "hatchmarks")
    .attr("patternUnits", "userSpaceOnUse")
    .attr("width", 5)
    .attr("height", 5);

  hatchPattern
    .append("path")
    .attr("d", "M-1,6 L6,-1")
    .attr("stroke", "var(--text)")
    .attr("stroke-linecap", "square")
    .attr("stroke-width", 0.8);

  hatchPattern
    .append("path")
    .attr("d", "M-1,1 L1,-1")
    .attr("stroke", "var(--text)")
    .attr("stroke-linecap", "square")
    .attr("stroke-width", 0.8);

  hatchPattern
    .append("path")
    .attr("d", "M4,6 L6,4")
    .attr("stroke", "var(--text)")
    .attr("stroke-linecap", "square")
    .attr("stroke-width", 0.8);

  // Dot pattern for none states - diagonal arrangement
  const dotPattern = defs
    .append("pattern")
    .attr("id", "dots")
    .attr("patternUnits", "userSpaceOnUse")
    .attr("width", 6)
    .attr("height", 6);

  // Create diagonal dots pattern
  dotPattern
    .append("circle")
    .attr("cx", 1.5)
    .attr("cy", 1.5)
    .attr("r", 0.6)
    .attr("fill", "var(--text)");

  dotPattern
    .append("circle")
    .attr("cx", 4.5)
    .attr("cy", 4.5)
    .attr("r", 0.6)
    .attr("fill", "var(--text)");

  // Create tooltip
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "state-tooltip")
    .style("position", "absolute")
    .style("visibility", "hidden")
    .style("background", "var(--text)")
    .style("color", "var(--bg)")
    .style("padding", "8px 12px")
    .style("border-radius", "4px")
    .style("font-size", "14px")
    .style("pointer-events", "none")
    .style("z-index", "1000");

  // Create paths for each state - use specific selector to avoid pattern paths
  const paths = svg
    .selectAll("path.state")
    .data(stateFeatures)
    .enter()
    .append("path")
    .attr("d", path)
    .attr("class", "state")
    .attr("stroke", "var(--bg)")
    .attr("stroke-width", 0);

  // Apply fills based on support level
  paths.each(function (d: any) {
    const element = d3.select(this);
    const supportLevel = d.properties.supportLevel;
    const stateName = d.properties.name;

    if (supportLevel === "full") {
      element.attr("fill", "var(--text)");
    } else if (supportLevel === "prioritized") {
      element.attr("fill", "url(#hatchmarks)");
    } else {
      // For "none" - use dot pattern
      element.attr("fill", "url(#dots)");
    }

    // Store support level for tooltip
    element.attr("data-support", supportLevel);
    element.attr("data-name", stateName);
  });

  // Add event handlers
  paths
    .on("mouseover", function (event: any, d: any) {
      const supportLevel = d.properties.supportLevel;
      let supportText = "";

      if (supportLevel === "full") {
        supportText = "Full Support";
      } else if (supportLevel === "prioritized") {
        supportText = "Prioritized Support";
      } else {
        supportText = "No Support Yet";
      }

      // Highlight the hovered state with thicker stroke
      d3.select(this).attr("stroke", "var(--text)").attr("stroke-width", 3);

      tooltip
        .style("visibility", "visible")
        .html(`<strong>${d.properties.name}</strong><br/>${supportText}`);
    })
    .on("mousemove", function (event: any) {
      tooltip
        .style("top", event.pageY + 16 + "px")
        .style("left", event.pageX + 16 + "px");
    })
    .on("mouseout", function () {
      // Reset all states to original stroke
      paths.attr("stroke", "var(--bg)").attr("stroke-width", 0);

      tooltip.style("visibility", "hidden");
    });

  // Create legend
  const legendData = [
    {
      type: "full",
      label: "Full Support",
      fill: "var(--text)",
      pattern: null,
    },
    {
      type: "prioritized",
      label: "Prioritized (Next Up)",
      fill: "url(#hatchmarks)",
      pattern: "hatchmarks",
    },
    {
      type: "none",
      label: "No Support Yet",
      fill: "url(#dots)",
      pattern: "dots",
    },
  ];

  const legendGroup = svg
    .append("g")
    .attr("class", "legend")
    .attr("transform", `translate(${width * 0.8}, 40)`);

  // Stack legend items vertically
  const legendItems = legendGroup
    .selectAll(".legend-item")
    .data(legendData)
    .enter()
    .append("g")
    .attr("class", "legend-item")
    .attr("transform", (d: any, i: number) => `translate(0, ${i * 24})`);

  // Add invisible background rectangles for better hover areas
  legendItems
    .append("rect")
    .attr("class", "legend-hover-area")
    .attr("x", -85)
    .attr("y", -12)
    .attr("width", 160)
    .attr("height", 24)
    .attr("fill", "transparent")
    .style("cursor", "pointer");

  // Add legend squares
  legendItems
    .append("rect")
    .attr("x", -80)
    .attr("y", -8)
    .attr("width", 16)
    .attr("height", 16)
    .attr("fill", (d: any) => d.fill)
    .attr("stroke", "var(--text)")
    .attr("stroke-width", 1.5)
    .attr("rx", 2);

  // Add legend text
  legendItems
    .append("text")
    .attr("x", -56)
    .attr("y", 5)
    .attr("font-size", "16px")
    .attr("fill", "var(--text)")
    .attr("text-anchor", "start")
    .text((d: any) => d.label);

  // Add interactive functionality to legend items
  legendItems
    .style("cursor", "pointer")
    .on("mouseover", function (event: any, d: any) {
      const hoveredType = d.type;

      // Dim all states
      paths.style("opacity", 0.25);

      // Highlight states matching the hovered legend item
      paths
        .filter(
          (stateData: any) => stateData.properties.supportLevel === hoveredType,
        )
        .style("opacity", 1);

      // Highlight the hovered legend item
      d3.select(this).style("opacity", 1);

      // Dim other legend items
      legendItems
        .filter((legendData: any) => legendData.type !== hoveredType)
        .style("opacity", 0.6);
    })
    .on("mouseout", function () {
      // Reset all states to full opacity and restore strokes
      paths.style("opacity", 1);

      // Reset all legend items to full opacity
      legendItems.style("opacity", 1);
    });

  // Append the SVG element
  container?.append(svg.node());
</script>

<style>
  .support {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-2xl);
    padding-block: var(--space-3xl);
  }

  header {
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-m);
    text-wrap: balance;
  }

  #support-map {
    width: 100%;
    max-width: 975px;
    margin: 0 auto;
  }
</style>
